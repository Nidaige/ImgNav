@model Solution
@using Microsoft.EntityFrameworkCore.Metadata.Internal
@{
    ViewData["Title"] = "Home Page";
}
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script>
var state = 0;
var startx = 0;
var starty = 0;
var endx = 0;
var endy = 0;
var inActiveButtonColor = "#EFEFEF";
var startSet = false;
var endSet = false;
console.log("Predefined start: "+startx+", "+starty+", Predefined end: "+endx+", "+endy);
var coords = [];
var solution = [];
var solution2 = "";
var dotColor = "black";
$(document).ready(function() {
    var cnvs = document.getElementById("displayedCanvas");
    document.getElementById("SetStartButton").style.background = "orange";
            $("canvas").on("click", function(event) {
                var x = event.pageX - cnvs.offsetLeft;
                var y = event.pageY - cnvs.offsetTop;
                if (state === 0){
                    startx = x;
                    starty = y;
                    coords[starty][startx]='S';
                    dotColor = "orange";
                    startSet = true;
                }
                else if (state === 1) {
                    endx = x;
                    endy = y;
                    coords[endy][endx]='E';
                    dotColor = "lightblue";
                    endSet = true;
                }
                console.log("start: "+startx+", "+starty+", end: "+endx+", "+endy);

                Draw(x, y,cnvs,dotColor, 3);
                });
            });
window.onload = function() {
    var canvas = document.getElementById("displayedCanvas");
    var img = document.getElementById("displayedImage");
    canvas.width = img.width;
    canvas.height = img.height;
    img.style.display = "none";
    var ctx = canvas.getContext("2d");
    ctx.drawImage(img,img.style.width, img.style.height);
    var imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
    document.getElementById("imgArray").innerHTML = imgData.data;
    var data = imgData.data;
    var rows = [];
    var currentrow = [];
    // Loop through data (serialized pixel RGBA-balues, so 4x pixel count elements), at every 4th element (each pixel)
    for(var it=0; it<data.length; it+=4) {
        // Add current pixel to current row
        //currentrow.push(new Uint8ClampedArray( [ data [ it ] ,data [ it + 1 ] ,data [ it + 2 ] ,data [ it + 3 ] ]));
        // This version only adds the sum of the pixel values, so black is 0 and white is 255
        var value = (data [ it ] + data [ it + 1 ] + data [ it + 2 ])/3;
        if (value==255){value = ' ';} else{value = 'X';}
   
        currentrow.push(value)
        //console.log("Iterator: "+it);
        // If Current pixel is at the end of a row, add current row to list of rows and empty current row.      
        if (currentrow.length === canvas.width)
        {
        rows.push(currentrow);
        currentrow = [];
        }
            }
    //console.log(rows);
    coords = rows;
};


function Draw(iX,iY,canvas,color, linwid){
var ctx = canvas.getContext("2d");

ctx.beginPath();
ctx.arc(iX-1.5, iY-1.5, linwid, 0, 2 * Math.PI, false);
ctx.lineWidth = linwid;
ctx.fillStyle=color;
ctx.fill();
console.log("clicked: "+iX+","+iY);

//

}

// Maze solver from http://jsfiddle.net/5g7se8qL/7/

function mazeSolver() {
   
    var maze = coords;
    
    //document.getElementById('original_maze').innerHTML = displayMaze(maze);
    
    var start = findStartEnd(maze,'S');
    var end = findStartEnd(maze,'E');
    console.log("Start: "+start+", end: "+end);
    
    fillMaze(maze, start);
   
    //document.getElementById('steps').innerHTML = displayMaze(maze);
    
    followSolution(maze, end);
    
    document.getElementById('SolString').value = solution2;
    console.log(solution2);
    var path = document.getElementById("PathStatus");
    var SolveForm = document.getElementById("SendSolutionForm");
    if (solution2.length>2){
        path.innerText="path found!";
        SolveForm.style.display="block";
    } else {
        path.innerText="No path :c";
        SolveForm.style.display="none";
    }
}

function followSolution(maze, end) {

    var height = maze.length;
    var width = maze[0].length;

    var cur_step = parseInt( maze[end[0]][end[1]] );
    //console.log("cur step before while: "+cur_step)
    
    maze[end[0]][end[1]] = 'o';
    
    while (cur_step > 1) {
        y = end[0];
        x = end[1];
        //console.log("end: "+end);
        solution.push(end.reverse());
        //console.log(solution);
        Draw(x,y,document.getElementById("displayedCanvas"),"Green", 1);
        //console.log("cur step inside while: "+cur_step);
        var get_out = 0;
        
        // check each of the neighbours (up down left right)
        for(var ny = -1; ny <= 1; ny++) { // If checking all neighbours this could be max(y-1,0):min(y+1,height)
            for(var nx = -1; nx <= 1; nx++) {
               if (Math.abs(ny) == Math.abs(nx) || y+ny < 0 || y+ny >= height || x+nx < 0 || x+nx >= width )
                    continue;


                if (maze[y+ny][x+nx] == (cur_step-1).toString()) {
                    end = [y+ny, x+nx];
                    cur_step = parseInt( maze[end[0]][end[1]] );
                    maze[y+ny][x+nx] = 'o';
                    get_out = 1;
                    break;
                }

            }
            if (get_out == 1) 
                break;

        }
    
    }
    solution2+="[";
    for (var a = 0; a<solution.length; a++){
        solution[a][0]-=startx;
        solution[a][1]-=starty;
    }
    solution2 += solution.reverse().join("], [");
    solution2+="]";
}

function displayMaze(maze) {
    
    var text = [];
    for (var y = 0; y < maze.length; y++){
        text.push(maze[y].join('')+'\n');
    }
    return text.join('');
}

function findStartEnd(maze,val) {

    var height = maze.length;
    var width = maze[0].length;
        
    // find start
    for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
            
            if (maze[y][x] == val) {
                // check the four directions
                for (var ny = -1; ny <= 1; ny++) {
                    for (var nx = -1; nx <= 1; nx++) {
                        if (Math.abs(ny) == Math.abs(nx) || y+ny < 0 || y+ny >= height || x+nx < 0 || x+nx >= width)
                            continue;
                        
                        if (maze[y+ny][x+nx] == ' ')
                            return [y+ny, x+nx];
                        
                    }
                }
            }
        }
    }
}

function fillMaze(maze, start) {

    maze[start[0]][start[1]] = '1';
    //document.getElementById('again').innerHTML = displayMaze(maze);
    var height = maze.length;
    var width = maze[0].length;
    
    queue = start;
    
    while (queue.length != 0) {
       
        var y = queue.shift();
        var x = queue.shift();
        var cur_val = parseInt(maze[y][x]);

        // check each of the neighbours
        for (var ny = -1; ny <= 1; ny++) {
            for (var nx = -1; nx <= 1; nx++) {
                if (Math.abs(ny) == Math.abs(nx) || y+ny < 0 || y+ny >= height || x+nx < 0 || x+nx >= width) 
                    continue;

                if (maze[y+ny][x+nx] == ' ') {
                    maze[y+ny][x+nx] = (cur_val+1).toString();
                    queue.push(y+ny);
                    queue.push(x+nx);
                }

            }
        }
        
        
        
    }

}

function setState(newState){
    var setStartButton = document.getElementById("SetStartButton");
    var setEndButton = document.getElementById("SetEndButton");
    state = newState;
    if (state === 1){
        setEndButton.style.background = "lightblue";
        setStartButton.style.background = inActiveButtonColor;    }
    else {
        setStartButton.style.background = "orange";
        setEndButton.style.background = inActiveButtonColor;
    }
    
}

function pathFinder (){
    if (startSet && endSet){
        mazeSolver();
    }
    else{
        alert("You need to set both the start and end point!");
    }
}
</script>
<h1 class="display-4">Navigation and coordinates for SPOT</h1>
    <h2>Images should not be greater than 4000x2800 pixels, and should be in the .png format</h2>
    <h2>The web-app uses the color white within images as "pathable" ground, so the drafts should do so as well</h2>
    <h3>Draft lines that denote measurements etc. can obstruct the app's performance</h3>
<h1 id="PathStatus"></h1>
<form asp-action="UploadImage" 
      asp-controller="Home" 
      method="post" 
      enctype="multipart/form-data">
    <input type="file" id="file1" 
           name="file1"/>
    <button type="submit">Upload File(s)</button>
</form>

<input id ="SetStartButton" type="button" value="Set Start" onclick= setState(0) style="display:@ViewBag.BtnVis">
<input id ="SetEndButton" type="button" value="Set End" onclick= setState(1) style="display:@ViewBag.BtnVis">

<div>Image title: @ViewBag.ImageTitle</div>
    <img id="displayedImage" src=@ViewBag.ImageDataUrl  style="display:block">
    <canvas id="displayedCanvas" ></canvas>
<div id="imgArray" style="display:none"></div>




<input id ="mazebutton" type="button" value="Solve" onclick= pathFinder() style="display:@ViewBag.BtnVis">

<form asp-controller="Home" asp-action="SendSolution" method="post" id="SendSolutionForm" style="display:none">
    <div class="form-group">
        <label asp-for="SolString" style="display:none"></label>
        <input asp-for="SolString" style="display:none">
    </div>
    <div class="form-group">
         <input type="submit" value="Send Solution" style="background:lightgreen">
      </div>
</form>




